<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manipulation Strategy Analysis</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .control-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .control-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        .control-value {
            font-size: 13px;
            color: #666;
            font-family: monospace;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // JavaScript port of calculation functions
        function calculatePManip(xVal, metricManipAmt, params) {
            const { pStartPrice, forecastDelta, costToIncreaseMetricPerIncrement, metricCostIncreasePerIncrement, grantValue, valueOfMetricIncrease, capitalOpportunityCost, maxForecast, priceImpact } = params;

            // loss from acquiring x shares
            const priceImpactLoss = xVal * (forecastDelta * priceImpact / maxForecast);
            // profit on shares if we do manip metric
            const mktProfit = xVal * (metricManipAmt / maxForecast);
            // cost of manipulating metric
            const costOfManipulatingMetric = (costToIncreaseMetricPerIncrement + metricManipAmt * metricCostIncreasePerIncrement / 2) * metricManipAmt;
            // value derived from manipulating metric
            const metricManipBenefit = valueOfMetricIncrease * metricManipAmt;
            // capital required to manip market and manip metric
            const manipCapitalReqs = xVal > 0 ? xVal * (pStartPrice * maxForecast + forecastDelta * priceImpact) / maxForecast + costOfManipulatingMetric : 0;

            // total pnl if we manip market, receive grant and do manip metric
            return (mktProfit - priceImpactLoss) - costOfManipulatingMetric + metricManipBenefit - manipCapitalReqs * capitalOpportunityCost;
        }

        function optimizeMManip(xVal, params) {
            const { pStartPrice, maxForecast } = params;
            // how much project decides to increase the metric by
            const maxMetricManipAmt = (1 - pStartPrice) * maxForecast;

            let optimalManip = 0;
            let optimalProfit = calculatePManip(xVal, 0, params);

            for (let m = 0; m <= maxMetricManipAmt; m += maxMetricManipAmt / 10000) {
                if (m < 0) continue;
                const p = calculatePManip(xVal, m, params);
                if (p > optimalProfit) {
                    optimalProfit = p;
                    optimalManip = m;
                }
            }

            return [optimalManip, optimalProfit];
        }

        function calculateManipulationStrategy(params) {
            const { pStartPrice, forecastDelta, maxForecast, priceImpact, capitalOpportunityCost, grantValue } = params;

            // Create range of x values (number of UP tokens purchased by project)
            const xVals = [];
            for (let i = 0; i <= 1000; i++) {
                xVals.push((i / 1000) * 20000000);
            }

            const results = xVals.map(x => {
                const [optimalManip, optimalProfit] = optimizeMManip(x, params);

                // total pnl, if we manip market, receive grant and do not manip metric
                // loss from acquiring x shares (reuse same calculation as in calculate_p_manip)
                const priceImpactLoss = x * (forecastDelta * priceImpact / maxForecast);
                // capital required to manip market (reuse same base calculation)
                const noManipCapitalReqs = x > 0 ? x * (pStartPrice * maxForecast + forecastDelta * priceImpact) / maxForecast : 0;
                const noManipProfit = grantValue - priceImpactLoss - noManipCapitalReqs * capitalOpportunityCost;

                // PnL of strategy with highest pnl (i.e. either manipulate metric or do not manipulate metric)
                const profitOfBestStrat = Math.max(optimalProfit, noManipProfit);

                // Only show optimal m_manip if p_manip is positive
                const optimalManip_final = optimalProfit > 0 ? optimalManip : 0;

                return {
                    x,
                    pManip: optimalProfit,
                    pNomanip: noManipProfit,
                    yPositive: profitOfBestStrat > 0 ? profitOfBestStrat : null,
                    yNegative: profitOfBestStrat < 0 ? profitOfBestStrat : null,
                    optimalM: optimalManip_final
                };
            });

            return results;
        }

        function ManipulationAnalysis() {
            const [params, setParams] = useState({
                // starting p price
                pStartPrice: 0.5,
                // how far project's impact is from the amount required to win
                forecastDelta: 30,
                // initial mechanical cost of increasing metric per mtvl., after increasing it by the amount required by the grant
                costToIncreaseMetricPerIncrement: 2000,
                // rate at which metric production cost increases per unit of metric increase. i.e. "cost acceleration rate" (dollars per unit of metric)
                metricCostIncreasePerIncrement: 15,
                // how much value the project assigns to winning
                grantValue: 35000,
                // how much project values each mtvl metric increase. we assume this is constant over the range.
                valueOfMetricIncrease: 700,
                // capital opp cost (incl. risk aversion) of project
                capitalOpportunityCost: 0.15,
                // how much price impact project incurs on their trade, as a proportion of how much they move the forecast. assume worst case scenario
                priceImpact: 0.5
            });

            // max forecast
            const maxForecast = 200;

            const plotRef = useRef();
            const [initialYRange, setInitialYRange] = useState(null);
            const [isFirstRender, setIsFirstRender] = useState(true);

            const paramConfig = {
                pStartPrice: { min: 0, max: 1, step: 0.01, label: 'Starting forecast price', format: (v) => `$${v}` },
                forecastDelta: { min: 0, max: maxForecast * (1 - params.pStartPrice), step: 1, label: 'Gap from required forecast to win', format: (v) => `${v} mtvl` },
                costToIncreaseMetricPerIncrement: { min: 0, max: 5000, step: 100, label: 'Initial cost to increase metric per increment', format: (v) => `$${v}` },
                metricCostIncreasePerIncrement: { min: 1, max: 50, step: 1, label: 'Cost increase rate per metric increment', format: (v) => `$${v}` },
                grantValue: { min: 0, max: 100000, step: 1000, label: 'Value project assigns to winning grant', format: (v) => `$${v.toLocaleString()}` },
                valueOfMetricIncrease: { min: 0, max: 5000, step: 10, label: 'Value per metric increment to project', format: (v) => `$${v}` },
                capitalOpportunityCost: { min: 0, max: 1, step: 0.01, label: 'Capital opportunity cost (incl. risk aversion)', format: (v) => `${(v * 100).toFixed(1)}%` },
                priceImpact: { min: 0.0, max: 1, step: 0.01, label: 'Price impact as proportion of forecast move', format: (v) => `${(v * 100).toFixed(1)}%` }
            };

            useEffect(() => {
                updateChart();
            }, [params]);

            const updateChart = () => {
                const data = calculateManipulationStrategy({ ...params, maxForecast });

                const xVals = data.map(d => d.x);
                const manipProfitVals = data.map(d => d.pManip);
                const noManipProfitVals = data.map(d => d.pNomanip);
                // Create one continuous y curve that shows the optimal value
                const profitOfBestStratVals = data.map(d => Math.max(d.pManip, d.pNomanip));
                const optimalManipVals = data.map(d => d.optimalM);

                // Use fixed scaling for m_manip to keep it consistent across parameter changes
                const scaledManipVals = optimalManipVals.map(m => m * 300);

                // Create arrays for negative portions of optimal profit curve
                const negativeOptimalX = [];
                const negativeOptimalY = [];
                for (let i = 0; i < xVals.length; i++) {
                    if (profitOfBestStratVals[i] < 0) {
                        negativeOptimalX.push(xVals[i]);
                        negativeOptimalY.push(profitOfBestStratVals[i]);
                    }
                }

                const traces = [
                    {
                        x: xVals,
                        y: manipProfitVals,
                        mode: 'lines',
                        name: 'profit of mkt manip + optimal metric manip',
                        line: { color: 'orange', width: 2 },
                        hovertemplate: '<b>p_manip</b><br>UP tokens: %{x:,.0f}<br>Profit: $%{y:,.0f}<extra></extra>'
                    },
                    {
                        x: xVals,
                        y: noManipProfitVals,
                        mode: 'lines',
                        name: 'profit of mkt manip only. no metric manip',
                        line: { color: 'blue', width: 2 },
                        hovertemplate: '<b>p_nomanip</b><br>UP tokens: %{x:,.0f}<br>Profit: $%{y:,.0f}<extra></extra>'
                    },
                    {
                        x: xVals,
                        y: profitOfBestStratVals,
                        mode: 'lines',
                        name: 'profit of best strat (pos)',
                        line: { color: 'green', width: 5 },
                        hovertemplate: '<b>y (optimal)</b><br>UP tokens: %{x:,.0f}<br>Profit: $%{y:,.0f}<extra></extra>'
                    },
                    {
                        x: negativeOptimalX,
                        y: negativeOptimalY,
                        mode: 'lines',
                        name: 'profit of best strat (neg)',
                        line: { color: 'red', width: 5 },
                        hovertemplate: '<b>y (optimal - losses)</b><br>UP tokens: %{x:,.0f}<br>Profit: $%{y:,.0f}<extra></extra>'
                    },
                    // {
                    //     x: xVals,
                    //     y: scaledManipVals,
                    //     mode: 'lines',
                    //     name: 'optimal m_manip (scaled)',
                    //     line: { color: 'purple', width: 2, dash: 'dash' },
                    //     customdata: optimalManipVals,
                    //     hovertemplate: '<b>optimal m_manip</b><br>UP tokens: %{x:,.0f}<br>Actual m_manip: %{customdata:.1f}<br>Scaled value: $%{y:,.0f}<extra></extra>'
                    // }
                ];

                // Only calculate y-range on first render
                let yRange;
                if (isFirstRender) {
                    const visibleData = data.filter(d => d.x <= 700000);
                    const visibleValues = [
                        ...visibleData.map(d => d.pManip),
                        ...visibleData.map(d => d.pNomanip),
                        ...visibleData.map(d => d.yPositive).filter(v => v !== null),
                        ...visibleData.map(d => d.yNegative).filter(v => v !== null)
                    ];
                    const yMin = Math.min(...visibleValues) * 1.1;
                    const yMax = Math.max(...visibleValues) * 1.1;
                    yRange = [yMin, yMax];
                    setInitialYRange(yRange);
                    setIsFirstRender(false);
                } else {
                    yRange = initialYRange;
                }

                const layout = {
                    title: 'Manipulation Strategy Analysis - All Curves',
                    xaxis: {
                        title: '# of UP tokens purchased by project',
                        ...(isFirstRender ? { range: [0, 700000] } : {})
                    },
                    yaxis: {
                        title: 'total $profit from manipulation',
                        ...(isFirstRender ? { range: yRange } : {})
                    },
                    showlegend: true,
                    hovermode: 'x unified',
                    template: 'plotly_white',
                    margin: { l: 80, r: 40, t: 80, b: 80 },
                    dragmode: 'pan'
                };

                const config = {
                    responsive: true,
                    scrollZoom: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['zoom2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'lasso2d', 'select2d'],
                    doubleClick: 'autosize'
                };

                if (isFirstRender) {
                    Plotly.newPlot(plotRef.current, traces, layout, config);
                } else {
                    // Only update the data, preserve the current view/zoom/pan
                    const update = {
                        x: traces.map(t => t.x),
                        y: traces.map(t => t.y),
                        customdata: traces.map(t => t.customdata || [])
                    };
                    Plotly.restyle(plotRef.current, update);
                }
            };

            const handleParamChange = (paramName, value) => {
                setParams(prev => ({
                    ...prev,
                    [paramName]: parseFloat(value)
                }));
            };

            return (
                <div className="container">
                    <h1>Manipulation Strategy Analysis</h1>

                    <div className="controls">
                        <div className="control-grid">
                            {Object.entries(paramConfig).map(([key, config]) => (
                                <div key={key} className="control-group">
                                    <div className="control-label">{config.label}</div>
                                    <input
                                        type="range"
                                        className="control-slider"
                                        min={config.min}
                                        max={config.max}
                                        step={config.step}
                                        value={params[key]}
                                        onChange={(e) => handleParamChange(key, e.target.value)}
                                    />
                                    <div className="control-value">{config.format ? config.format(params[key]) : params[key]}</div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="chart-container">
                        <div ref={plotRef} style={{ width: '100%', height: '600px' }}></div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<ManipulationAnalysis />, document.getElementById('root'));
    </script>
</body>

</html>